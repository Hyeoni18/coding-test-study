# 다이나믹 프로그래밍
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법이다.
# 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다. 완전탐색을 사용하여 비효율적인 시간복잡도라 하여도 다이나믹 프로그래밍으로 시간복잡도를 획기적으로 줄일 수 있는 경우가 많다.
# 일반적으로 두 가지 방식으로 구성된다. 탑다운(하향식)과 보텀업(상향식).
# 동적 계획법이라고도 부르는데 일반적인 프로그래밍 분야에서의 동적과는 차이가 있다. 자료구조에선 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'이지만, 여기선 별다른 의미 없이 사용된 단어다.

# 다음의 조건을 만족할 때 사용할 수 있다.
# 1. 최적 부분 구조(Optimal Substructure), 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아 큰 문제를 해결할 수 있다.
# 2. 중복되는 부분 문제(Overlapping Subproblem), 부분문제가 서로 중첩되어 여러번 등장한다는 의미이고 동일한 작은 문제를 반복적으로 해결해야 한다.
# 대표적인 예제는 피보나치 수열이 있다.

# 피보나치 함수를 재귀함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))

# 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시작 복잡도를 가지게 된다. (중복되는 부분 문제) 피보나치 수열의 효율적인 해법은 다이나믹 프로그래밍이다.
# 메모이제이션(Memoization), 다이나믹 프로그래밍을 구현하는 방법 중 하나이다. 한 번 계산한 결과를 메모리 공간에 메모하는 기법. 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져오며, 캐싱이라고도 한다.
# 탑다운(메모이제이션) vs 보텀업, 탑다운은 재귀함수를 사용. 보텀업은 반복문을 사용. 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이며, 여기서 사용되는 결과 저장용 리스트는 DP 테이블이라고 부른다.

# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
d = [0] * 100 # 이렇게 해준 이유는 간단히 예제에서 99번째 피보나치 수를 구하기 때문임.
# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건 (1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))

# 피보나치 수열: 보텀업 방법
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100
# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1 (반복문이 사용되기에, 종료조건 대신 시작 항을 초기화)
d[1] = 1
d[2] = 1
n = 99
# 피보나치 함수 반복문으로 구현
for i in range(3, n+1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])